# This file contains ideas, design plans, mindmap, ... you name it,
# for libspiffextension_python.

Background
-----------
libspiffextension is the most important part of the Spiff platform.
Because most of Spiff's functionality is built around this component,
it is very important to get it right.
The library performs the following tasks:

   - Installing plugins.
   - Deleting plugins.
   - Ensuring that dependencies between plugins are consistent at
     any given time.
   - Loading plugins when they are needed.
   - Unloading plugins when they are no longer needed.
   - It provides a facility over which plugins can communicate with
     each other.
   - It provides a facility that controls which kind of communication
     may or may not be taken between plugins.

libspiffextension may also run plugins inside of a sandbox, and apply
permission restrictions to them. This functionality will only be added
at a later point, however.


Design
-------
* Extension class: Type for any plugin. An extension has a list of
  dependencies. Dependencies may be grouped into contexts, such as "runtime"
  or "install_time" dependencies. libspiffextension only ever checks the
  dependencies within each context, dependencies accross multiple contexts are
  unchecked.
  Extensions may also send signals, or listen to signals emitted by the
  EventBus, if the have the permission to do so.

* Callback class: A callback is a function owned by an Extension that is hooked
  into a specific EventBus signal.

* DB class: The list of installed plugins, dependencies, callbacks and other
  properties are stored within the database. This class abstracts the database
  from the rest of the library.

* Manager class: This is the core public API, providing the client with methods
  for installing and uninstalling plugins, and configuring any options of them.
  It also provides secure (authenticated) access to the EventBus.
  Before an extension is installed, the Manager determines the dependencies of
  the extension and ensures that they are fullfilled.
  It also retrieves a list of all EventBus signals to which the extension would
  like to subscribe. It then delegates the decision of whether permission to
  access the events is granted to the client (=whoever owns the manager).


API:

add_extension(extension : Extension, permission_request = None : func)
 1. Create extension.
 2. Check runtime dependencies and reference dependencies of the extension.
 3. Retrieve callback requests from the extension.
 4. Call the permission_request function (if passed to add_extension) to
    determine whether permission to the requested callback/event is granted.
    The permission_request function has the following signature:
      permission_request(extension, cb_name, context)
    where
      extension: is the extension that is to be registered
      uri:       is URI addressing the event that the extension would like
                 to catch.
 5. Register the extension in DB.
 6. Add the list of dependencies into the DB.
 7. Add a list of all callbacks into the DB.

emit(name)
 1. Find out which extensions are registered against that callback.
 2. Load them, including runtime dependencies.
 3. Call the callbacks.


Extension Design
----------------

* Extensions have headers consisting out of comments.
* Fields in the header:
   - extension name
   - extension handle (ascii name without special chars)
   - extension version
   - extension author
   - extension description
   - a list of all runtime dependencies
   - a list of all install time dependencies
   - a list of all event URIs that the extension might want to subscribe to.

Events to which the extension might want to subscribe:

- Any time any page is opened, regardless of whether the extension
  is integrated into that site.
  event_uri: "always", cb: on_page_open
- Any time a specified page is opened.
  event_uri: "site:/path/to/page/*", cb: on_page_open
- Any time a page is opened that loads a specified extension.
  event_uri: "extension:handle=version", cb: on_page_open
